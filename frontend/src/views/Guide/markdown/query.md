依托于详尽的项目属性和标签系统，Hedge能够使用一种较为强力的方式查询图库、分区、画集和来源数据等。在这些页面的顶栏，搜索框使用Hedge查询语法完成查询，以下将其简称为HQL。

HQL的内容并不能用三言两语解释完毕，而直接开始说明书也过于难懂，因此我们从例子开始。

### 查询第一个标签

在图库中，假设需要查询标签“doujinshi”所关联的所有图像，那么使用单个标签名称即可：
```
doujinshi
```
或者，使用专门的模糊匹配语法时，只输入单词的一部分也能完成查询：
```
dou*shi     //=> *匹配任意0~N个任意字符。进行的查询实际上是LIKE 'dou%shi'
douj?nshi   //=> ?匹配1个任意字符。进行的查询实际上是LIKE 'douj_nshi'
```


### 查询多个标签

如果要查询多个标签，那么使用多个标签名即可，这会查询同时关联了这两个标签的图像：
```
A B
A & B        //=> & 符号是显式的AND连接
```
如果要查询关联了A或B的图像，则使用`|`或`/`:
```
A | B
A / B
```
如果要排除A，则使用`-`:
```
-A
-A -B       //=> 既排除A也排除B
-A|B        //=> 这其实与上一种等价
```
也可以联合使用几种模式：
```
A|B C|D & -E/F/G     //=> (A or B) and (C or D) and (not(E or F or G))
```
然而，由于性能优化的需要，HQL在或模式上有很大的限制：
* 只支持合取范式，因此合用时只支持如上的AND(NOT(OR))的嵌套模式。
* 每一个合取项必须是同一类型，比如都是主题，或都是作者。匹配只会在一个大类进行，跨大类会导致匹配不到项。

### 精确查询标签

现在，假设需要查询的标签是“hello world”，但空格会把它隔成两个单词，虽然也不是不能用，但显然这离精确查询有点远。

有一个解决方案是在「设置」-「查询」中打开「转义普通下划线」。此时，**下划线会被转义为空格**，就可以这么查询：
```
hello_world
```
不过，我们还有更多精确查询的办法来应对更复杂的标签名。使用单引号`'`或双引号`"`括起一个字符串，就不会引起误解了。如果标签名称中还有更复杂的符号和结构，那还可以使用转义符号：
```
'hello world'
"idol@master"           //=> 可自由使用单引号或双引号，只要不混淆配对
"\n \t \r \' \" \` \\"  //=> 在引号内使用的转义符号
```
标签的匹配会同时搜索它们的名称和所有别名。而当有的标签存在重复的别名时，使用上述方法是无法精确匹配到单一一个标签的。此时，使用反引号` `` `，查询将是**完全精确**的，不会模糊匹配，且只匹配标签的**第一名称**，避免任何误解的可能：
```
`hello world`           //=> 仅匹配第一名称等于hello world的标签，而不理会别名
```
即使使用了反引号精确查询，也仍然不能说我们可以唯一定位每一个标签，因为有些标签全局范围可重名(主题组下的子主题、标签地址段)，更何况标签一定可以跨大类重名。为了解决这两个问题，可以使用**地址段匹配**和**类型限定符**。

类型限定符通过在标签前面添加`@ # $`符号，限定此标签的大类。如果不加限定符号，那么搜索的优先顺序是标签 > 主题 > 作者。
```
@zun        //=> 仅在作者(Author)中查找
#eva        //=> 仅在主题(Topic)中查找
$A          //=> 仅在标签(Tag)中查找
```

地址段匹配则通过地址段限定的方式缩小搜索范围。地址段匹配不要求完全地址段匹配，它只要求子标签有一个间接父标签满足上一段即可，且也不要求首段必须是顶层标签。
```
A.B.C           //=> 匹配C，要求其有一个父标签B，再上又有一个A

```
还可以混用以上手段。
```
$A.B.C          //=> 与类型限定符一起使用
$`A`.`B`.`C`    //=> 使用精确标签名
$A.`B`|C        //=> 它们的优先级关系是$((A.B)|C)
```

### 范围匹配

在元数据标签-标签-组一节中提到过，组/序列化组能够依照其成组性质，完成一些更复杂的匹配运算。假如我们有序列化组`X.Y.Z(a, b, c, d, e, f)`，则可以对它使用下述高级语法。

匹配一个组下属的指定几个标签。
```
X.Z:{a, b}      //=> 匹配a or b
```
匹配一个序列化组中根据范围限定出来的一部分标签。
```
Z >= c      //=> 匹配c, d, e, f
Z > c       //=> 匹配d, e, f
Z <= d      //=> 匹配a, b, c, d
Z < d       //=> 匹配a, b, c
Z:[b, e]    //=> 匹配b, c, d, e
Z:(b, e)    //=> 匹配c, d
Z:[b, e)    //=> 匹配b, c, d
Z:(b, e]    //=> 匹配c, d, e
```
不想写组名时，还有一个简便语法：
```
X.Y.Z.a ~ c //=> 匹配a, b, c
d ~ a       //=> 匹配a, b, c, d
c ~+        //=> 匹配c, d, e, f
b ~-        //=> 匹配a, b
```

### 查询注解

查询注解时，使用相似但略有不同的语法。与注解的表现形式一样，我们使用方括号`[]`将内容包裹起来：
```
[jp_game]       //=> 匹配注解jp game
```
注解也可以使用类型限定符来限定注解的目标类型：
```
[@cn_artist]    //=> 匹配作者注解
[#jp_game]      //=> 匹配主题注解
[$guro]         //=> 匹配标签注解
```
注解也可以使用逻辑关联来查询：
```
[A][B] [C|D] -[E] //=> 匹配(A and B and (C or D) and (not E))
```

### 查询其他属性

除了操作标签，HQL还可以利用图像/集合等的各类属性。下面以图库查询为例，讲解几个属性的查询方法。

查询收藏的项，使用`favorite`/`f`关键字。
```
favorite    //=> 查询收藏的项
f           //=> 可以简写为f
-f          //=> 否定，查询未被收藏的项
```
根据评分筛选，使用`score`关键字。在这里可以使用各类上面提到的高级语法。
```
score: 5        //=> 查询评分为5的项
score >= 3      //=> 查询评分大于等于3的项
score: [2, 4)   //=> 查询评分大于等于2且小于4的项
score: {1, 3}   //=> 查询评分为1或3的项
```
根据ID筛选，使用`id`关键字。ID这类属性尽管是数值，但仍可使用字符串模糊匹配语法。
```
id: 4396        //=> 查找id为4396的项
id >= 4396      //=> 查找id大于等于4396的项
id: [123, 456]  //=> 查找id大于等于123且小于等于456的项
id: {1, 4, 7}   //=> 查找id为1、4、7的项
id: 4396????    //=> 可索引的数值匹配，这会查找[43960000, 43970000)范围内的项
id: *4396*      //=> 不可索引的模糊匹配，这会查找id LIKE '%4396%'的项
```
根据创建时间筛选，使用`create-time`/`create`/`ct`关键字。根据时间查询的属性，其最大查询精度只能到日。
```
create-time: 2023-01-01         //=> 查询创建时间为2023年1月1日的项
create-time: 2023-01            //=> 查询创建时间为2023年1月的项
create-time: 10-01              //=> 查询创建时间为今年10月1日的项
create-time: 10                 //=> 查询创建时间为今年10月的项
ct: "2023/01.01"                //=> 这两种分隔符也可以，只不过要搭配引号
ct: [2023-01-01, 2024-01-01]    //=> 查询2023年1月1日到2024年1月1日的项
ct: [2023, 2025)                //=> 查询2023年1月1日到2024年12月31日的项
```
根据描述信息模糊查询，使用`description`/`desc`关键字。
```
description: hello      //=> 查找description LIKE '%hello%'的项
description: h*o        //=> 查找description LIKE '%h%o%'的项
description: `hello`    //=> 查找description = 'hello'的项
```
根据扩展名查询，使用`extension`/`ext`关键字。
```
extension: jpeg                 //=> 查询jpeg类型
extension: {jpeg, jpg, png}     //=> 查询jpeg、jpg、png类型
```
根据文件大小查询，使用`filesize`/`size`关键字。  
该关键字使用文件容量格式，支持的单位有`B KB MB GB TB KiB MiB GiB TiB`。单位无视大小写，只支持整数。B使用1000进制，iB使用1024进制。
```
filesize: 150KB         //=> 查询大小为150KB的项(虽然这种精确值没人会用到)
filesize >= 1MiB        //=> 查询大于等于1MiB的项
size: [512k, 2m]        //=> 查询大小在512KB~2MB之间的项
```
根据Tagme查询。
```
tagme                   //=> 查询有Tagme的项
tagme: author           //=> 查询有Author类型的Tagme的项
tagme: {tag, topic, author, source}     //=> 查询有如下类型之一的Tagme的项
```
关键字属性查询同样支持AND、OR、NOT方式的连接。它们的连接方式比标签要灵活一些，允许跨类型OR，但仍不允许与标签用OR连接。  
关键字形式的查询与标签的查询并没有什么语法上的显著差异。如果存在名称混淆，比如要查询的标签名与某个关键字名冲突了，那么使用之前提到的引号语法即可。
```
favorite|id>10000       //=> 查询收藏的项，或id大于10000的项
favorite|A              //=> 错误的用法：关键字不能与标签查询一同使用
"favorite"              //=> 匹配名为favorite的标签
```

### 查询来源属性

在图库中，也支持根据来源属性直接查询。其语法与查询其他属性极为类似。不过，所有的来源属性都有一个带`^`符号的简写。使用`^`符号简写时，此符号位于整合合取项的最前，且整个合取项只能包含来源属性。
```
^site: pixiv        //=> 查询来源站点为pixiv的项
^id: 4396??         //=> 查询来源ID为4396??的项
^A                  //=> 匹配来源标签A
^pixiv:A            //=> 匹配来自pixiv的来源标签A
^p.artist:A         //=> 匹配来自包含p的site、type包含artist的来源标签A，site和type默认支持模糊匹配
^`pixiv`.`A`        //=> 匹配来自pixiv的来源标签A，对于site名称和标签名称均精确匹配
^A|B ^C id:1000     //=> 匹配(A or B) and C and id = 1000
```

### 排序

使用`sort`关键字，对查询结果进行排序。
```
sort: create-time  //=> 按创建时间升序排序
sort: +ct          //=> 等价，简写，可显式写出升序排序符号
sort: -score, id   //=> 先按score降序排序，再按id升序排序
sort: -^id         //=> 按来源ID降序排序。只有数字ID会参与排序，字符串ID会被排除在外
```
